<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Movie Hardware Order App</title>
  <!-- Load React and ReactDOM -->
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <!-- Load Babel for JSX transformation -->
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.22.9/babel.min.js"></script>
  <!-- Load Firebase modular SDK -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
    import { getFirestore, collection, addDoc, onSnapshot, updateDoc, doc, deleteDoc, query, where, getDocs, writeBatch } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js';
    import { getStorage, ref, uploadBytes, getDownloadURL } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js';

    // Expose Firebase functions to global scope for React app
    window.firebase = { initializeApp, getFirestore, collection, addDoc, onSnapshot, updateDoc, doc, deleteDoc, query, where, getDocs, writeBatch, getStorage, ref, uploadBytes, getDownloadURL };
  </script>
  <!-- Load Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect } = React;

    // Firebase configuration for set-hardware project
    const firebaseConfig = {
      apiKey: "AIzaSyCRbUS6L7O4I_gGaaCmCyHi7wt_WgMwZFc",
      authDomain: "set-hardware.firebaseapp.com",
      projectId: "set-hardware",
      storageBucket: "set-hardware.firebasestorage.app",
      messagingSenderId: "613195230835",
      appId: "1:613195230835:web:5dfaaf04dafa06d06ec406"
    };

    // Initialize Firebase
    let db, storage;
    let firebaseInitialized = false;
    try {
      const app = firebase.initializeApp(firebaseConfig);
      db = firebase.getFirestore(app);
      storage = firebase.getStorage(app);
      firebaseInitialized = true;
      console.log('Firebase initialized successfully');
    } catch (error) {
      console.error('Firebase initialization error:', error.message);
    }

    function App() {
      const [activeTab, setActiveTab] = useState('home');
      const [formData, setFormData] = useState({
        itemName: '',
        pickupFrom: '',
        orderNumber: '',
        deliveryMethod: 'shipped',
        startDate: '',
        endDate: '',
        set: '',
        recipient: '',
        received: false,
        pickedUpBy: ''
      });
      const [image, setImage] = useState(null);
      const [orders, setOrders] = useState([]);
      const [archivedOrders, setArchivedOrders] = useState([]);
      const [sets, setSets] = useState([]);
      const [recipients, setRecipients] = useState([]);
      const [newSet, setNewSet] = useState('');
      const [newRecipient, setNewRecipient] = useState('');
      const [uploading, setUploading] = useState(false);
      const [error, setError] = useState(null);
      const [selectedOrder, setSelectedOrder] = useState(null);

      // Fetch orders, archived orders, sets, and recipients from Firestore
      useEffect(() => {
        if (!firebaseInitialized || !db) {
          console.error('Firestore database not initialized');
          setError('Firestore database not initialized. Please check Firebase configuration.');
          return;
        }

        console.log('Setting up Firestore listeners...');
        // Fetch orders
        const unsubscribeOrders = firebase.onSnapshot(firebase.collection(db, 'orders'), (snapshot) => {
          const ordersData = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
          }));
          console.log('Fetched orders:', ordersData);
          setOrders(ordersData);
        }, (err) => {
          console.error('Firestore fetch error (orders):', err.message, err.code);
          setError(`Failed to fetch orders: ${err.message}`);
        });

        // Fetch archived orders
        const unsubscribeArchived = firebase.onSnapshot(firebase.collection(db, 'archive'), (snapshot) => {
          const archivedData = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
          }));
          console.log('Fetched archived orders:', archivedData);
          setArchivedOrders(archivedData);
        }, (err) => {
          console.error('Firestore fetch error (archive):', err.message, err.code);
          setError(`Failed to fetch archived orders: ${err.message}`);
        });

        // Fetch sets
        const unsubscribeSets = firebase.onSnapshot(firebase.collection(db, 'sets'), (snapshot) => {
          const setsData = snapshot.docs.map(doc => ({
            id: doc.id,
            name: doc.data().name
          }));
          console.log('Fetched sets:', setsData);
          setSets(setsData);
        }, (err) => {
          console.error('Firestore fetch error (sets):', err.message, err.code);
          setError(`Failed to fetch sets: ${err.message}`);
        });

        // Fetch recipients
        const unsubscribeRecipients = firebase.onSnapshot(firebase.collection(db, 'recipients'), (snapshot) => {
          const recipientsData = snapshot.docs.map(doc => ({
            id: doc.id,
            name: doc.data().name
          }));
          console.log('Fetched recipients:', recipientsData);
          setRecipients(recipientsData);
        }, (err) => {
          console.error('Firestore fetch error (recipients):', err.message, err.code);
          setError(`Failed to fetch recipients: ${err.message}`);
        });

        return () => {
          console.log('Cleaning up Firestore listeners');
          unsubscribeOrders();
          unsubscribeArchived();
          unsubscribeSets();
          unsubscribeRecipients();
        };
      }, []);

      const handleInputChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({ ...prev, [name]: value }));
      };

      const handleImageChange = (e) => {
        if (e.target.files[0]) {
          setImage(e.target.files[0]);
          console.log('Selected image:', e.target.files[0].name, 'Size:', e.target.files[0].size);
        }
      };

      const handleSubmit = async (e) => {
        e.preventDefault();
        if (!firebaseInitialized || !db || !storage) {
          console.error('Firebase not initialized for submit');
          setError('Firebase not initialized. Check configuration.');
          return;
        }
        setUploading(true);
        setError(null);

        try {
          let imageUrl = '';
          if (image) {
            console.log('Uploading image:', image.name);
            const storageRef = firebase.ref(storage, `images/${Date.now()}_${image.name}`);
            await firebase.uploadBytes(storageRef, image);
            imageUrl = await firebase.getDownloadURL(storageRef);
            console.log('Image uploaded successfully, URL:', imageUrl);
          }

          const orderData = { ...formData, imageUrl, timestamp: new Date() };
          console.log('Submitting order:', orderData);
          const docRef = await firebase.addDoc(firebase.collection(db, 'orders'), orderData);
          console.log('Order saved successfully with ID:', docRef.id);

          // Reset form to default values
          setFormData({
            itemName: '',
            pickupFrom: '',
            orderNumber: '',
            deliveryMethod: 'shipped',
            startDate: '',
            endDate: '',
            set: '',
            recipient: '',
            received: false,
            pickedUpBy: ''
          });
          setImage(null);
          document.querySelector('input[type="file"]').value = ''; // Reset file input
          alert('Order submitted successfully!');
        } catch (error) {
          console.error('Error submitting order:', error.message, error.code);
          setError(`Error submitting order: ${error.message} (Code: ${error.code})`);
        } finally {
          setUploading(false);
        }
      };

      const toggleReceived = async (id, currentStatus, pickedUpBy) => {
        if (!firebaseInitialized || !db) {
          console.error('Firestore not initialized for toggleReceived');
          setError('Firebase not initialized.');
          return;
        }
        try {
          console.log(`Toggling received status for order ${id}, new status: ${!currentStatus}, pickedUpBy: ${pickedUpBy}`);
          await firebase.updateDoc(firebase.doc(db, 'orders', id), {
            received: !currentStatus,
            pickedUpBy: !currentStatus ? pickedUpBy : ''
          });
          console.log('Received status updated successfully');
        } catch (error) {
          console.error('Error updating received status:', error.message, error.code);
          setError(`Error updating status: ${error.message} (Code: ${error.code})`);
        }
      };

      const addSet = async (e) => {
        e.preventDefault();
        if (!firebaseInitialized || !db || !newSet.trim()) {
          console.error('Firestore not initialized or empty set name');
          setError('Cannot add set: Firebase not initialized or set name is empty.');
          return;
        }
        try {
          console.log('Adding set:', newSet.trim());
          const docRef = await firebase.addDoc(firebase.collection(db, 'sets'), { name: newSet.trim() });
          console.log('Set added successfully with ID:', docRef.id);
          setNewSet('');
        } catch (error) {
          console.error('Error adding set:', error.message, error.code);
          setError(`Error adding set: ${error.message} (Code: ${error.code})`);
        }
      };

      const deleteSet = async (id, setName) => {
        if (!firebaseInitialized || !db) {
          console.error('Firestore not initialized for deleteSet');
          setError('Firebase not initialized.');
          return;
        }
        if (!window.confirm(`Are you sure you want to delete the set "${setName}"? All associated orders will be archived.`)) return;
        try {
          console.log(`Deleting set ${setName} (ID: ${id}) and archiving orders`);
          const ordersQuery = firebase.query(firebase.collection(db, 'orders'), firebase.where('set', '==', setName));
          const ordersSnapshot = await firebase.getDocs(ordersQuery);
          console.log(`Found ${ordersSnapshot.size} orders for set ${setName}`);

          const batch = firebase.writeBatch(db);
          ordersSnapshot.forEach(doc => {
            const orderData = doc.data();
            batch.set(firebase.doc(db, 'archive', doc.id), { ...orderData, archivedAt: new Date() });
            batch.delete(firebase.doc(db, 'orders', doc.id));
          });

          batch.delete(firebase.doc(db, 'sets', id));
          await batch.commit();
          console.log('Set deleted and orders archived successfully');
        } catch (error) {
          console.error('Error deleting set:', error.message, error.code);
          setError(`Error deleting set or archiving orders: ${error.message} (Code: ${error.code})`);
        }
      };

      const restoreSet = async (setName) => {
        if (!firebaseInitialized || !db) {
          console.error('Firestore not initialized for restoreSet');
          setError('Firebase not initialized.');
          return;
        }
        try {
          console.log(`Restoring set ${setName}`);
          const batch = firebase.writeBatch(db);
          const setDocRef = firebase.doc(firebase.collection(db, 'sets'));
          batch.set(setDocRef, { name: setName });

          const archivedQuery = firebase.query(firebase.collection(db, 'archive'), firebase.where('set', '==', setName));
          const archivedSnapshot = await firebase.getDocs(archivedQuery);
          console.log(`Found ${archivedSnapshot.size} archived orders for set ${setName}`);

          archivedSnapshot.forEach(doc => {
            const orderData = doc.data();
            batch.set(firebase.doc(db, 'orders', doc.id), { ...orderData });
            batch.delete(firebase.doc(db, 'archive', doc.id));
          });

          await batch.commit();
          console.log('Set restored successfully with ID:', setDocRef.id);
        } catch (error) {
          console.error('Error restoring set:', error.message, error.code);
          setError(`Error restoring set: ${error.message} (Code: ${error.code})`);
        }
      };

      const addRecipient = async (e) => {
        e.preventDefault();
        if (!firebaseInitialized || !db || !newRecipient.trim()) {
          console.error('Firestore not initialized or empty recipient name');
          setError('Cannot add recipient: Firebase not initialized or recipient name is empty.');
          return;
        }
        try {
          console.log('Adding recipient:', newRecipient.trim());
          const docRef = await firebase.addDoc(firebase.collection(db, 'recipients'), { name: newRecipient.trim() });
          console.log('Recipient added successfully with ID:', docRef.id);
          setNewRecipient('');
        } catch (error) {
          console.error('Error adding recipient:', error.message, error.code);
          setError(`Error adding recipient: ${error.message} (Code: ${error.code})`);
        }
      };

      const deleteRecipient = async (id) => {
        if (!firebaseInitialized || !db) {
          console.error('Firestore not initialized for deleteRecipient');
          setError('Firebase not initialized.');
          return;
        }
        try {
          console.log(`Deleting recipient ID: ${id}`);
          await firebase.deleteDoc(firebase.doc(db, 'recipients', id));
          console.log('Recipient deleted successfully');
        } catch (error) {
          console.error('Error deleting recipient:', error.message, error.code);
          setError(`Error deleting recipient: ${error.message} (Code: ${error.code})`);
        }
      };

      // Function to escape LaTeX special characters
      const escapeLatex = (str) => {
        if (!str) return '';
        return str.replace(/([&%$#_{}])/g, '\\$1')
                 .replace(/\\/g, '\\textbackslash')
                 .replace(/~/g, '\\textasciitilde')
                 .replace(/\^/g, '\\textasciicircum');
      };

      // Generate LaTeX for PDF export
      const generateLatex = (orders, title) => {
        const groupedOrders = orders.reduce((acc, order) => {
          const setName = order.set || 'Unknown Set';
          if (!acc[setName]) acc[setName] = [];
          acc[setName].push(order);
          return acc;
        }, {});

        let latexContent = `
\\documentclass{article}
\\usepackage[utf8]{inputenc}
\\usepackage{geometry}
\\geometry{a4paper, margin=1in}
\\usepackage{booktabs}
\\usepackage{longtable}
\\usepackage{hyperref}
\\usepackage{fancyhdr}
\\pagestyle{fancy}
\\fancyhf{}
\\fancyhead[C]{Hardware Order Report}
\\fancyfoot[C]{\\thepage}
\\title{${escapeLatex(title)}}
\\author{}
\\date{${new Date().toLocaleDateString()}}
\\begin{document}
\\maketitle
`;

        Object.keys(groupedOrders).sort().forEach(setName => {
          latexContent += `
\\section*{Set: ${escapeLatex(setName)}}
\\begin{longtable}{p{4cm}p{3cm}p{3cm}p{3cm}p{4cm}p{3cm}p{3cm}}
\\toprule
Item Name & Pickup From & Order Number & Delivery & Shipping Dates & Recipient & Status \\\\
\\midrule
`;
          groupedOrders[setName]
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
            .forEach(order => {
              const status = order.received ? `Received${order.pickedUpBy ? ' by ' + escapeLatex(order.pickedUpBy) : ''}` : 'Not Received';
              latexContent += `
${escapeLatex(order.itemName)} & ${escapeLatex(order.pickupFrom)} & ${escapeLatex(order.orderNumber)} & ${escapeLatex(order.deliveryMethod)} & ${escapeLatex(order.startDate)} to ${escapeLatex(order.endDate)} & ${escapeLatex(order.recipient)} & ${escapeLatex(status)} \\\\
`;
              if (order.imageUrl) {
                latexContent += `\\multicolumn{7}{l}{\\href{${order.imageUrl}}{Image Link}} \\\\`;
              }
            });
          latexContent += `
\\bottomrule
\\end{longtable}
`;
        });

        latexContent += `
\\end{document}
`;
        return latexContent;
      };

      // Export PDF for a given set of orders
      const exportToPDF = (orders, title) => {
        console.log(`Exporting PDF for ${title}`);
        const latexContent = generateLatex(orders, title);
        const blob = new Blob([latexContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${title.replace(/\s+/g, '_')}.tex`;
        a.click();
        URL.revokeObjectURL(url);
        console.log(`Generated LaTeX file for ${title}`);
      };

      // Open modal with order details
      const openOrderModal = (order) => {
        setSelectedOrder(order);
        console.log('Opening modal for order:', order.id);
      };

      // Close modal
      const closeOrderModal = () => {
        setSelectedOrder(null);
        console.log('Closing modal');
      };

      // Group archived orders by set
      const groupedArchivedOrders = archivedOrders.reduce((acc, order) => {
        const setName = order.set || 'Unknown Set';
        if (!acc[setName]) acc[setName] = [];
        acc[setName].push(order);
        return acc;
      }, {});

      // Group completed orders by set
      const completedOrders = orders.filter(order => order.received);
      const groupedCompletedOrders = completedOrders.reduce((acc, order) => {
        const setName = order.set || 'Unknown Set';
        if (!acc[setName]) acc[setName] = [];
        acc[setName].push(order);
        return acc;
      }, {});

      // Active orders (not received)
      const activeOrders = orders.filter(order => !order.received);

      // Fallback UI if Firebase is not initialized
      if (!firebaseInitialized) {
        return (
          <div className="container mx-auto p-4">
            <h1 className="text-3xl font-bold mb-6 text-center">Hardware Order Management</h1>
            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
              Error: Firebase not initialized. Please check your Firebase configuration and ensure the project is active.
            </div>
          </div>
        );
      }

      return (
        <div className="container mx-auto p-4">
          <h1 className="text-3xl font-bold mb-6 text-center">Hardware Order Management</h1>

          {/* Tabs */}
          <div className="flex border-b mb-6">
            <button
              className={`px-4 py-2 font-semibold ${activeTab === 'home' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-600'}`}
              onClick={() => setActiveTab('home')}
            >
              Home
            </button>
            <button
              className={`px-4 py-2 font-semibold ${activeTab === 'completed' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-600'}`}
              onClick={() => setActiveTab('completed')}
            >
              Completed Orders
            </button>
            <button
              className={`px-4 py-2 font-semibold ${activeTab === 'options' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-600'}`}
              onClick={() => setActiveTab('options')}
            >
              Options
            </button>
            <button
              className={`px-4 py-2 font-semibold ${activeTab === 'orders' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-600'}`}
              onClick={() => setActiveTab('orders')}
            >
              Orders
            </button>
            <button
              className={`px-4 py-2 font-semibold ${activeTab === 'archive' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-600'}`}
              onClick={() => setActiveTab('archive')}
            >
              Archive
            </button>
          </div>

          {/* Error Display */}
          {error && (
            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
              {error}
            </div>
          )}

          {/* Order Modal */}
          {selectedOrder && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
              <div className="bg-white p-8 rounded-lg shadow-lg max-w-lg w-full">
                <h2 className="text-2xl font-semibold mb-4">Order Details</h2>
                <div className="space-y-4 text-lg">
                  <p><strong>Item Name:</strong> {selectedOrder.itemName}</p>
                  <p><strong>Pickup From:</strong> {selectedOrder.pickupFrom}</p>
                  <p><strong>Order Number:</strong> {selectedOrder.orderNumber}</p>
                  <p><strong>Delivery:</strong> {selectedOrder.deliveryMethod}</p>
                  <p><strong>Shipping Dates:</strong> {selectedOrder.startDate} to {selectedOrder.endDate}</p>
                  <p><strong>Set:</strong> {selectedOrder.set}</p>
                  <p><strong>Recipient:</strong> {selectedOrder.recipient}</p>
                  <p><strong>Received:</strong> {selectedOrder.received ? 'Yes' : 'No'}</p>
                  {selectedOrder.received && selectedOrder.pickedUpBy && (
                    <p><strong>Picked Up By:</strong> {selectedOrder.pickedUpBy}</p>
                  )}
                  {selectedOrder.imageUrl && (
                    <div>
                      <p><strong>Image:</strong></p>
                      <img src={selectedOrder.imageUrl} alt="Order item" className="w-full max-h-96 object-contain rounded" />
                    </div>
                  )}
                </div>
                <button
                  onClick={closeOrderModal}
                  className="mt-6 w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                >
                  Close
                </button>
              </div>
            </div>
          )}

          {/* Home Tab (Active Orders Only) */}
          {activeTab === 'home' && (
            <div>
              <div className="flex justify-end mb-4">
                <button
                  onClick={() => exportToPDF(activeOrders, 'Active_Orders')}
                  className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                  disabled={!firebaseInitialized}
                >
                  Export Active Orders to PDF
                </button>
              </div>
              <h2 className="text-2xl font-semibold mb-4">Active Orders</h2>
              {activeOrders.length === 0 ? (
                <p className="text-gray-600">No active orders found.</p>
              ) : (
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {activeOrders.map(order => (
                    <div key={order.id} className="bg-white p-4 rounded-lg shadow-md">
                      <h3 className="text-lg font-semibold">{order.itemName}</h3>
                      <p><strong>Pickup From:</strong> {order.pickupFrom}</p>
                      <p><strong>Order Number:</strong> {order.orderNumber}</p>
                      <p><strong>Delivery:</strong> {order.deliveryMethod}</p>
                      <p><strong>Shipping Dates:</strong> {order.startDate} to {order.endDate}</p>
                      <p><strong>Set:</strong> {order.set}</p>
                      <p><strong>Recipient:</strong> {order.recipient}</p>
                      <p><strong>Received:</strong> {order.received ? 'Yes' : 'No'}</p>
                      {order.imageUrl && (
                        <img src={order.imageUrl} alt="Order item" className="w-full h-32 object-cover rounded mt-2" />
                      )}
                      <div className="mt-2 flex space-x-2">
                        <select
                          onChange={(e) => toggleReceived(order.id, order.received, e.target.value)}
                          className="w-full p-2 border rounded"
                          defaultValue=""
                        >
                          <option value="" disabled>Select Pickup Person</option>
                          {recipients.map(recipient => (
                            <option key={recipient.id} value={recipient.name}>{recipient.name}</option>
                          ))}
                        </select>
                        <button
                          onClick={() => openOrderModal(order)}
                          className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                        >
                          Expand
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}

          {/* Orders Tab (New Order Form Only) */}
          {activeTab === 'orders' && (
            <div className="max-w-lg mx-auto bg-white p-6 rounded-lg shadow-md">
              <h2 className="text-2xl font-semibold mb-4">New Order</h2>
              <form onSubmit={handleSubmit} className="space-y-4">
                <input
                  type="text"
                  name="itemName"
                  value={formData.itemName}
                  onChange={handleInputChange}
                  placeholder="Item Name"
                  className="w-full p-2 border rounded"
                  required
                />
                <input
                  type="text"
                  name="pickupFrom"
                  value={formData.pickupFrom}
                  onChange={handleInputChange}
                  placeholder="Pickup From"
                  className="w-full p-2 border rounded"
                  required
                />
                <input
                  type="text"
                  name="orderNumber"
                  value={formData.orderNumber}
                  onChange={handleInputChange}
                  placeholder="Order Number"
                  className="w-full p-2 border rounded"
                  required
                />
                <select
                  name="deliveryMethod"
                  value={formData.deliveryMethod}
                  onChange={handleInputChange}
                  className="w-full p-2 border rounded"
                >
                  <option value="shipped">Shipped</option>
                  <option value="pickup">Pickup</option>
                </select>
                <div className="flex space-x-2">
                  <input
                    type="date"
                    name="startDate"
                    value={formData.startDate}
                    onChange={handleInputChange}
                    placeholder="Shipping Start Date"
                    className="w-full p-2 border rounded"
                    required
                  />
                  <input
                    type="date"
                    name="endDate"
                    value={formData.endDate}
                    onChange={handleInputChange}
                    placeholder="Shipping End Date"
                    className="w-full p-2 border rounded"
                    required
                  />
                </div>
                <input
                  type="file"
                  onChange={handleImageChange}
                  accept="image/*"
                  className="w-full p-2 border rounded"
                />
                <select
                  name="set"
                  value={formData.set}
                  onChange={handleInputChange}
                  className="w-full p-2 border rounded"
                  required
                >
                  <option value="">Select Set</option>
                  {sets.map(set => (
                    <option key={set.id} value={set.name}>{set.name}</option>
                  ))}
                </select>
                <select
                  name="recipient"
                  value={formData.recipient}
                  onChange={handleInputChange}
                  className="w-full p-2 border rounded"
                  required
                >
                  <option value="">Select Recipient</option>
                  {recipients.map(recipient => (
                    <option key={recipient.id} value={recipient.name}>{recipient.name}</option>
                  ))}
                </select>
                <button
                  type="submit"
                  disabled={uploading || !firebaseInitialized}
                  className="w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600 disabled:bg-blue-300"
                >
                  {uploading ? 'Submitting...' : 'Submit Order'}
                </button>
              </form>
            </div>
          )}

          {/* Completed Orders Tab */}
          {activeTab === 'completed' && (
            <div className="max-w-4xl mx-auto">
              <div className="flex justify-end mb-4">
                <button
                  onClick={() => exportToPDF(completedOrders, 'Completed_Orders')}
                  className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                  disabled={!firebaseInitialized}
                >
                  Export Completed Orders to PDF
                </button>
              </div>
              <h2 className="text-2xl font-semibold mb-4">Completed Orders</h2>
              {Object.keys(groupedCompletedOrders).length === 0 ? (
                <p className="text-gray-600">No completed orders found.</p>
              ) : (
                Object.keys(groupedCompletedOrders).sort().map(setName => (
                  <div key={setName} className="mb-8">
                    <h3 className="text-xl font-semibold mb-4">{setName}</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                      {groupedCompletedOrders[setName]
                        .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
                        .map(order => (
                          <div key={order.id} className="bg-white p-4 rounded-lg shadow-md">
                            <h4 className="text-lg font-semibold">{order.itemName}</h4>
                            <p><strong>Pickup From:</strong> {order.pickupFrom}</p>
                            <p><strong>Order Number:</strong> {order.orderNumber}</p>
                            <p><strong>Delivery:</strong> {order.deliveryMethod}</p>
                            <p><strong>Shipping Dates:</strong> {order.startDate} to {order.endDate}</p>
                            <p><strong>Recipient:</strong> {order.recipient}</p>
                            <p><strong>Received:</strong> Yes</p>
                            {order.pickedUpBy && (
                              <p><strong>Picked Up By:</strong> {order.pickedUpBy}</p>
                            )}
                            {order.imageUrl && (
                              <img src={order.imageUrl} alt="Order item" className="w-full h-32 object-cover rounded mt-2" />
                            )}
                            <div className="mt-2 flex space-x-2">
                              <button
                                onClick={() => toggleReceived(order.id, order.received, '')}
                                className="w-full bg-gray-500 text-white p-2 rounded hover:bg-blue-600"
                              >
                                Undo Received
                              </button>
                              <button
                                onClick={() => openOrderModal(order)}
                                className="w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                              >
                                Expand
                              </button>
                            </div>
                          </div>
                        ))}
                    </div>
                  </div>
                ))
              )}
            </div>
          )}

          {/* Options Tab */}
          {activeTab === 'options' && (
            <div className="max-w-lg mx-auto bg-white p-6 rounded-lg shadow-md">
              <h2 className="text-2xl font-semibold mb-4">Options</h2>
              <div className="space-y-6">
                {/* Manage Sets */}
                <div>
                  <h3 className="text-lg font-semibold mb-2">Manage Sets</h3>
                  <form onSubmit={addSet} className="flex space-x-2 mb-4">
                    <input
                      type="text"
                      value={newSet}
                      onChange={(e) => setNewSet(e.target.value)}
                      placeholder="Add New Set"
                      className="w-full p-2 border rounded"
                    />
                    <button
                      type="submit"
                      disabled={!firebaseInitialized}
                      className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600 disabled:bg-blue-300"
                    >
                      Add
                    </button>
                  </form>
                  <ul className="space-y-2">
                    {sets.map(set => (
                      <li key={set.id} className="flex justify-between items-center">
                        <span>{set.name}</span>
                        <button
                          onClick={() => deleteSet(set.id, set.name)}
                          className="text-red-500 hover:text-red-700"
                          disabled={!firebaseInitialized}
                        >
                          Delete
                        </button>
                      </li>
                    ))}
                  </ul>
                </div>
                {/* Manage Recipients */}
                <div>
                  <h3 className="text-lg font-semibold mb-2">Manage Recipients</h3>
                  <form onSubmit={addRecipient} className="flex space-x-2 mb-4">
                    <input
                      type="text"
                      value={newRecipient}
                      onChange={(e) => setNewRecipient(e.target.value)}
                      placeholder="Add New Recipient"
                      className="w-full p-2 border rounded"
                    />
                    <button
                      type="submit"
                      disabled={!firebaseInitialized}
                      className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600 disabled:bg-blue-300"
                    >
                      Add
                    </button>
                  </form>
                  <ul className="space-y-2">
                    {recipients.map(recipient => (
                      <li key={recipient.id} className="flex justify-between items-center">
                        <span>{recipient.name}</span>
                        <button
                          onClick={() => deleteRecipient(recipient.id)}
                          className="text-red-500 hover:text-red-700"
                          disabled={!firebaseInitialized}
                        >
                          Delete
                        </button>
                      </li>
                    ))}
                  </ul>
                </div>
              </div>
            </div>
          )}

          {/* Archive Tab */}
          {activeTab === 'archive' && (
            <div className="max-w-4xl mx-auto">
              <div className="flex justify-end mb-4">
                <button
                  onClick={() => exportToPDF(archivedOrders, 'Archived_Orders')}
                  className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                  disabled={!firebaseInitialized}
                >
                  Export Archived Orders to PDF
                </button>
              </div>
              <h2 className="text-2xl font-semibold mb-4">Archived Orders</h2>
              {Object.keys(groupedArchivedOrders).length === 0 ? (
                <p className="text-gray-600">No archived orders found.</p>
              ) : (
                Object.keys(groupedArchivedOrders).sort().map(setName => (
                  <div key={setName} className="mb-8">
                    <div className="flex justify-between items-center mb-4">
                      <h3 className="text-xl font-semibold">{setName}</h3>
                      <button
                        onClick={() => restoreSet(setName)}
                        className="bg-green-500 text-white p-2 rounded hover:bg-green-600"
                        disabled={!firebaseInitialized}
                      >
                        Restore Set
                      </button>
                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                      {groupedArchivedOrders[setName].map(order => (
                        <div key={order.id} className="bg-white p-4 rounded-lg shadow-md">
                          <h4 className="text-lg font-semibold">{order.itemName}</h4>
                          <p><strong>Pickup From:</strong> {order.pickupFrom}</p>
                          <p><strong>Order Number:</strong> {order.orderNumber}</p>
                          <p><strong>Delivery:</strong> {order.deliveryMethod}</p>
                          <p><strong>Shipping Dates:</strong> {order.startDate} to {order.endDate}</p>
                          <p><strong>Recipient:</strong> {order.recipient}</p>
                          <p><strong>Received:</strong> {order.received ? 'Yes' : 'No'}</p>
                          {order.received && order.pickedUpBy && (
                            <p><strong>Picked Up By:</strong> {order.pickedUpBy}</p>
                          )}
                          {order.imageUrl && (
                            <img src={order.imageUrl} alt="Order item" className="w-full h-32 object-cover rounded mt-2" />
                          )}
                          <div className="mt-2">
                            <button
                              onClick={() => openOrderModal(order)}
                              className="w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                            >
                              Expand
                            </button>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                ))
              )}
            </div>
          )}
        </div>
      );
    }

    // Render the app
    try {
      ReactDOM.render(<App />, document.getElementById('root'));
    } catch (error) {
      console.error('React render error:', error.message);
      document.getElementById('root').innerHTML = '<div className="text-red-500 text-center">Error loading application: ' + error.message + '</div>';
    }
  </script>
</body>
</html>
