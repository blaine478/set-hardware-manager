<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Movie Hardware Order App</title>
  <!-- Load React and ReactDOM -->
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <!-- Load Babel for JSX transformation -->
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.22.9/babel.min.js"></script>
  <!-- Load Firebase modular SDK -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
    import { getFirestore, collection, addDoc, onSnapshot, updateDoc, doc, deleteDoc, query, where, getDocs, writeBatch, Timestamp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js';
    import { getStorage, ref, uploadBytes, getDownloadURL } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js';

    // Expose Firebase functions to global scope for React app
    window.firebase = { initializeApp, getFirestore, collection, addDoc, onSnapshot, updateDoc, doc, deleteDoc, query, where, getDocs, writeBatch, Timestamp, getStorage, ref, uploadBytes, getDownloadURL };
  </script>
  <!-- Load jsPDF and jspdf-autotable -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js"></script>
  <!-- Load pre-built Tailwind CSS -->
  <link href="https://unpkg.com/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect } = React;
    const { jsPDF } = window.jspdf;

    // Firebase configuration for set-hardware project
    const firebaseConfig = {
      apiKey: "AIzaSyCRbUS6L7O4I_gGaaCmCyHi7wt_WgMwZFc",
      authDomain: "set-hardware.firebaseapp.com",
      projectId: "set-hardware",
      storageBucket: "set-hardware.firebasestorage.app",
      messagingSenderId: "613195230835",
      appId: "1:613195230835:web:5dfaaf04dafa06d06ec406"
    };

    // Initialize Firebase
    let db, storage;
    let firebaseInitialized = false;
    try {
      const app = firebase.initializeApp(firebaseConfig);
      db = firebase.getFirestore(app);
      storage = firebase.getStorage(app);
      firebaseInitialized = true;
      console.log('Firebase initialized successfully');
    } catch (error) {
      console.error('Firebase initialization error:', error.message);
    }

    // Request notification permission
    const requestNotificationPermission = async () => {
      if (!("Notification" in window)) {
        console.log("Notifications not supported in this browser");
        alert("Notifications are not supported in this browser.");
        return false;
      }
      try {
        const permission = await Notification.requestPermission();
        console.log('Notification permission:', permission);
        if (permission !== 'granted') {
          alert('Notification permission denied. You will not receive browser notifications.');
        }
        return permission === 'granted';
      } catch (error) {
        console.error('Error requesting notification permission:', error.message);
        alert('Error requesting notification permission: ' + error.message);
        return false;
      }
    };

    // Error Boundary Component
    function ErrorBoundary({ children }) {
      const [hasError, setHasError] = useState(false);
      const [errorMessage, setErrorMessage] = useState('');

      useEffect(() => {
        const errorHandler = (error) => {
          console.error('Error in component:', error.message);
          setHasError(true);
          setErrorMessage(error.message);
        };
        window.addEventListener('error', errorHandler);
        return () => window.removeEventListener('error', errorHandler);
      }, []);

      if (hasError) {
        return (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
            Error rendering component: {errorMessage}. Please refresh the page or check the console for details.
          </div>
        );
      }
      return children;
    }

    function App() {
      const [activeTab, setActiveTab] = useState('home');
      const [formData, setFormData] = useState({
        itemName: '',
        pickupFrom: '',
        orderNumber: '',
        deliveryMethod: 'shipped',
        startDate: '',
        endDate: '',
        deliveryDate: '',
        set: '',
        recipient: '',
        received: false,
        pickedUpBy: '',
        receivedAt: null
      });
      const [image, setImage] = useState(null);
      const [orders, setOrders] = useState([]);
      const [archivedOrders, setArchivedOrders] = useState([]);
      const [sets, setSets] = useState([]);
      const [recipients, setRecipients] = useState([]);
      const [newSet, setNewSet] = useState('');
      const [newRecipient, setNewRecipient] = useState('');
      const [uploading, setUploading] = useState(false);
      const [error, setError] = useState(null);
      const [selectedOrder, setSelectedOrder] = useState(null);
      const [showReceivedModal, setShowReceivedModal] = useState(false);
      const [receivedOrderId, setReceivedOrderId] = useState(null);
      const [pickedUpBy, setPickedUpBy] = useState('');
      const [editOrder, setEditOrder] = useState(null);
      const [recipientFilter, setRecipientFilter] = useState('');

      // Request notification permission on mount
      useEffect(() => {
        requestNotificationPermission();
      }, []);

      // Fetch orders, archived orders, sets, and recipients from Firestore
      useEffect(() => {
        if (!firebaseInitialized || !db) {
          console.error('Firestore database not initialized');
          setError('Firestore database not initialized. Please check Firebase configuration.');
          return;
        }

        console.log('Setting up Firestore listeners...');
        const unsubscribeOrders = firebase.onSnapshot(firebase.collection(db, 'orders'), (snapshot) => {
          const ordersData = snapshot.docs.map(doc => {
            const data = doc.data();
            return {
              id: doc.id,
              ...data,
              receivedAt: data.receivedAt ? data.receivedAt.toDate() : null,
              timestamp: data.timestamp ? data.timestamp.toDate() : null
            };
          });
          console.log('Fetched orders:', ordersData);
          setOrders(ordersData);
        }, (err) => {
          console.error('Firestore fetch error (orders):', err.message, err.code);
          setError(`Failed to fetch orders: ${err.message} (Code: ${err.code})`);
        });

        const unsubscribeArchived = firebase.onSnapshot(firebase.collection(db, 'archive'), (snapshot) => {
          const archivedData = snapshot.docs.map(doc => {
            const data = doc.data();
            return {
              id: doc.id,
              ...data,
              receivedAt: data.receivedAt ? data.receivedAt.toDate() : null,
              timestamp: data.timestamp ? data.timestamp.toDate() : null,
              archivedAt: data.archivedAt ? data.archivedAt.toDate() : null
            };
          });
          console.log('Fetched archived orders:', archivedData);
          setArchivedOrders(archivedData);
        }, (err) => {
          console.error('Firestore fetch error (archive):', err.message, err.code);
          setError(`Failed to fetch archived orders: ${err.message} (Code: ${err.code})`);
        });

        const unsubscribeSets = firebase.onSnapshot(firebase.collection(db, 'sets'), (snapshot) => {
          const setsData = snapshot.docs.map(doc => ({
            id: doc.id,
            name: doc.data().name || ''
          }));
          console.log('Fetched sets:', setsData);
          setSets(setsData);
        }, (err) => {
          console.error('Firestore fetch error (sets):', err.message, err.code);
          setError(`Failed to fetch sets: ${err.message} (Code: ${err.code})`);
        });

        const unsubscribeRecipients = firebase.onSnapshot(firebase.collection(db, 'recipients'), (snapshot) => {
          const recipientsData = snapshot.docs.map(doc => ({
            id: doc.id,
            name: doc.data().name || ''
          }));
          console.log('Fetched recipients:', recipientsData);
          setRecipients(recipientsData);
        }, (err) => {
          console.error('Firestore fetch error (recipients):', err.message, err.code);
          setError(`Failed to fetch recipients: ${err.message} (Code: ${err.code})`);
        });

        return () => {
          console.log('Cleaning up Firestore listeners');
          unsubscribeOrders();
          unsubscribeArchived();
          unsubscribeSets();
          unsubscribeRecipients();
        };
      }, []);

      const handleInputChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({ ...prev, [name]: value }));
      };

      const handleEditInputChange = (e) => {
        const { name, value } = e.target;
        setEditOrder(prev => ({ ...prev, [name]: value }));
      };

      const handleImageChange = (e) => {
        if (e.target.files[0]) {
          const file = e.target.files[0];
          if (file.size > 5 * 1024 * 1024) {
            console.error('Image too large:', file.size);
            setError('Image file is too large. Please select a file under 5MB.');
            return;
          }
          setImage(file);
          console.log('Selected image:', file.name, 'Size:', file.size);
        }
      };

      const handleSubmit = async (e) => {
        e.preventDefault();
        if (!firebaseInitialized || !db || !storage) {
          console.error('Firebase not initialized for submit');
          setError('Firebase not initialized. Check configuration.');
          setUploading(false);
          return;
        }
        setUploading(true);
        setError(null);

        try {
          let imageUrl = formData.imageUrl || '';
          if (image) {
            console.log('Uploading image:', image.name);
            const storageRef = firebase.ref(storage, `images/${Date.now()}_${image.name}`);
            await firebase.uploadBytes(storageRef, image);
            imageUrl = await firebase.getDownloadURL(storageRef);
            console.log('Image uploaded successfully, URL:', imageUrl);
          }

          const orderData = {
            ...formData,
            imageUrl,
            timestamp: firebase.Timestamp.fromDate(new Date())
          };
          console.log('Submitting order to Firestore:', orderData);
          const docRef = await firebase.addDoc(firebase.collection(db, 'orders'), orderData);
          console.log('Order saved successfully with ID:', docRef.id);

          // Send notification
          if (Notification.permission === 'granted') {
            try {
              new Notification('New Order Created', {
                body: `Order "${formData.itemName || 'Unknown'}" has been created for set "${formData.set || 'Unknown'}".`,
                icon: '/icon.png'
              });
              console.log('Notification sent for order creation');
            } catch (notificationError) {
              console.error('Error sending notification:', notificationError.message);
              alert('Order created, but failed to send notification: ' + notificationError.message);
            }
          } else {
            console.log('Notifications not permitted, skipping notification');
            alert('Order created, but notifications are disabled. Please enable browser notifications.');
          }

          // Reset form to default values
          setFormData({
            itemName: '',
            pickupFrom: '',
            orderNumber: '',
            deliveryMethod: 'shipped',
            startDate: '',
            endDate: '',
            deliveryDate: '',
            set: '',
            recipient: '',
            received: false,
            pickedUpBy: '',
            receivedAt: null
          });
          setImage(null);
          document.querySelector('input[type="file"]').value = '';
          alert('Order submitted successfully!');
        } catch (error) {
          console.error('Error submitting order:', error.message, error.code);
          setError(`Error submitting order: ${error.message} (Code: ${error.code})`);
        } finally {
          setUploading(false);
        }
      };

      const openReceivedModal = (orderId) => {
        setReceivedOrderId(orderId);
        setPickedUpBy('');
        setShowReceivedModal(true);
        console.log('Opening received modal for order:', orderId);
      };

      const closeReceivedModal = () => {
        setShowReceivedModal(false);
        setReceivedOrderId(null);
        setPickedUpBy('');
        console.log('Closing received modal');
      };

      const confirmReceived = async () => {
        if (!firebaseInitialized || !db || !receivedOrderId || !pickedUpBy) {
          console.error('Firestore not initialized or missing pickup person');
          setError('Cannot mark as received: Firebase not initialized or pickup person not selected.');
          return;
        }
        try {
          const receivedAt = firebase.Timestamp.fromDate(new Date());
          console.log(`Marking order ${receivedOrderId} as received by ${pickedUpBy} at ${receivedAt.toDate().toLocaleString()}`);
          await firebase.updateDoc(firebase.doc(db, 'orders', receivedOrderId), {
            received: true,
            pickedUpBy,
            receivedAt
          });
          console.log('Order marked as received successfully with timestamp:', receivedAt.toDate());

          // Send notification
          if (Notification.permission === 'granted') {
            try {
              const order = orders.find(o => o.id === receivedOrderId) || {};
              new Notification('Order Received', {
                body: `Order "${order.itemName || 'Unknown'}" was received by ${pickedUpBy} for set "${order.set || 'Unknown'}".`,
                icon: '/icon.png'
              });
              console.log('Notification sent for order receipt');
            } catch (notificationError) {
              console.error('Error sending notification:', notificationError.message);
              alert('Order marked as received, but failed to send notification: ' + notificationError.message);
            }
          } else {
            console.log('Notifications not permitted, skipping notification');
            alert('Order marked as received, but notifications are disabled. Please enable browser notifications.');
          }

          closeReceivedModal();
        } catch (error) {
          console.error('Error marking order as received:', error.message, error.code);
          setError(`Error marking order as received: ${error.message} (Code: ${error.code})`);
        }
      };

      const toggleReceived = async (id, currentStatus) => {
        if (!firebaseInitialized || !db) {
          console.error('Firestore not initialized for toggleReceived');
          setError('Firebase not initialized.');
          return;
        }
        try {
          console.log(`Toggling received status for order ${id}, new status: ${!currentStatus}`);
          await firebase.updateDoc(firebase.doc(db, 'orders', id), {
            received: !currentStatus,
            pickedUpBy: !currentStatus ? '' : '',
            receivedAt: !currentStatus ? null : null
          });
          console.log('Received status updated successfully');
        } catch (error) {
          console.error('Error updating received status:', error.message, error.code);
          setError(`Error updating status: ${error.message} (Code: ${error.code})`);
        }
      };

      const deleteOrder = async (id) => {
        if (!firebaseInitialized || !db) {
          console.error('Firestore not initialized for deleteOrder');
          setError('Firebase not initialized.');
          return;
        }
        if (!window.confirm('Are you sure you want to delete this order? This action cannot be undone.')) return;
        try {
          console.log(`Deleting order ID: ${id}`);
          await firebase.deleteDoc(firebase.doc(db, 'orders', id));
          console.log('Order deleted successfully');
        } catch (error) {
          console.error('Error deleting order:', error.message, error.code);
          setError(`Error deleting order: ${error.message} (Code: ${error.code})`);
        }
      };

      const openEditModal = (order) => {
        setEditOrder({
          id: order.id,
          itemName: order.itemName || '',
          pickupFrom: order.pickupFrom || '',
          orderNumber: order.orderNumber || '',
          deliveryMethod: order.deliveryMethod || 'shipped',
          startDate: order.startDate || '',
          endDate: order.endDate || '',
          deliveryDate: order.deliveryDate || '',
          set: order.set || '',
          recipient: order.recipient || '',
          imageUrl: order.imageUrl || ''
        });
        setImage(null);
        console.log('Opening edit modal for order:', order.id);
      };

      const closeEditModal = () => {
        setEditOrder(null);
        setImage(null);
        console.log('Closing edit modal');
      };

      const handleEditSubmit = async (e) => {
        e.preventDefault();
        if (!firebaseInitialized || !db || !storage) {
          console.error('Firebase not initialized for edit submit');
          setError('Firebase not initialized.');
          return;
        }
        try {
          let imageUrl = editOrder.imageUrl;
          if (image) {
            console.log('Uploading new image for edit:', image.name);
            const storageRef = firebase.ref(storage, `images/${Date.now()}_${image.name}`);
            await firebase.uploadBytes(storageRef, image);
            imageUrl = await firebase.getDownloadURL(storageRef);
            console.log('Image uploaded successfully, URL:', imageUrl);
          }

          const updatedOrder = { ...editOrder, imageUrl };
          console.log('Updating order:', updatedOrder);
          await firebase.updateDoc(firebase.doc(db, 'orders', editOrder.id), updatedOrder);
          console.log('Order updated successfully with ID:', editOrder.id);
          closeEditModal();
          alert('Order updated successfully!');
        } catch (error) {
          console.error('Error updating order:', error.message, error.code);
          setError(`Error updating order: ${error.message} (Code: ${error.code})`);
        }
      };

      const addSet = async (e) => {
        e.preventDefault();
        if (!firebaseInitialized || !db || !newSet.trim()) {
          console.error('Firestore not initialized or empty set name');
          setError('Cannot add set: Firebase not initialized or set name is empty.');
          return;
        }
        try {
          console.log('Adding set:', newSet.trim());
          const docRef = await firebase.addDoc(firebase.collection(db, 'sets'), { name: newSet.trim() });
          console.log('Set added successfully with ID:', docRef.id);
          setNewSet('');
        } catch (error) {
          console.error('Error adding set:', error.message, error.code);
          setError(`Error adding set: ${error.message} (Code: ${error.code})`);
        }
      };

      const deleteSet = async (id, setName) => {
        if (!firebaseInitialized || !db) {
          console.error('Firestore not initialized for deleteSet');
          setError('Firebase not initialized.');
          return;
        }
        if (!window.confirm(`Are you sure you want to delete the set "${setName}"? All associated orders will be archived.`)) return;
        try {
          console.log(`Deleting set ${setName} (ID: ${id}) and archiving orders`);
          const ordersQuery = firebase.query(firebase.collection(db, 'orders'), firebase.where('set', '==', setName));
          const ordersSnapshot = await firebase.getDocs(ordersQuery);
          console.log(`Found ${ordersSnapshot.size} orders for set ${setName}`);

          const batch = firebase.writeBatch(db);
          ordersSnapshot.forEach(doc => {
            const orderData = doc.data();
            batch.set(firebase.doc(db, 'archive', doc.id), { ...orderData, archivedAt: firebase.Timestamp.fromDate(new Date()) });
            batch.delete(firebase.doc(db, 'orders', doc.id));
          });

          batch.delete(firebase.doc(db, 'sets', id));
          await batch.commit();
          console.log('Set deleted and orders archived successfully');
        } catch (error) {
          console.error('Error deleting set:', error.message, error.code);
          setError(`Error deleting set or archiving orders: ${error.message} (Code: ${error.code})`);
        }
      };

      const restoreSet = async (setName) => {
        if (!firebaseInitialized || !db) {
          console.error('Firestore not initialized for restoreSet');
          setError('Firebase not initialized.');
          return;
        }
        try {
          console.log(`Restoring set ${setName}`);
          const batch = firebase.writeBatch(db);
          const setDocRef = firebase.doc(firebase.collection(db, 'sets'));
          batch.set(setDocRef, { name: setName });

          const archivedQuery = firebase.query(firebase.collection(db, 'archive'), firebase.where('set', '==', setName));
          const archivedSnapshot = await firebase.getDocs(archivedQuery);
          console.log(`Found ${archivedSnapshot.size} archived orders for set ${setName}`);

          archivedSnapshot.forEach(doc => {
            const orderData = doc.data();
            batch.set(firebase.doc(db, 'orders', doc.id), { ...orderData });
            batch.delete(firebase.doc(db, 'archive', doc.id));
          });

          await batch.commit();
          console.log('Set restored successfully with ID:', setDocRef.id);
        } catch (error) {
          console.error('Error restoring set:', error.message, error.code);
          setError(`Error restoring set: ${error.message} (Code: ${error.code})`);
        }
      };

      const addRecipient = async (e) => {
        e.preventDefault();
        if (!firebaseInitialized || !db || !newRecipient.trim()) {
          console.error('Firestore not initialized or empty recipient name');
          setError('Cannot add recipient: Firebase not initialized or recipient name is empty.');
          return;
        }
        try {
          console.log('Adding recipient:', newRecipient.trim());
          const docRef = await firebase.addDoc(firebase.collection(db, 'recipients'), { name: newRecipient.trim() });
          console.log('Recipient added successfully with ID:', docRef.id);
          setNewRecipient('');
        } catch (error) {
          console.error('Error adding recipient:', error.message, error.code);
          setError(`Error adding recipient: ${error.message} (Code: ${error.code})`);
        }
      };

      const deleteRecipient = async (id) => {
        if (!firebaseInitialized || !db) {
          console.error('Firestore not initialized for deleteRecipient');
          setError('Firebase not initialized.');
          return;
        }
        try {
          console.log(`Deleting recipient ID: ${id}`);
          await firebase.deleteDoc(firebase.doc(db, 'recipients', id));
          console.log('Recipient deleted successfully');
        } catch (error) {
          console.error('Error deleting recipient:', error.message, error.code);
          setError(`Error deleting recipient: ${error.message} (Code: ${error.code})`);
        }
      };

      // Function to check if order is new (within 7 days)
      const isOrderNew = (order) => {
        if (!order.timestamp) return false;
        const now = new Date();
        const orderDate = order.timestamp;
        const diffDays = (now - orderDate) / (1000 * 60 * 60 * 24);
        return diffDays <= 7;
      };

      // Print individual order as professional order form
      const printOrderForm = (order) => {
        console.log(`Generating order form for order: ${order.id}`);
        try {
          const doc = new jsPDF();
          doc.setFontSize(18);
          doc.text('Order Form', 20, 20);
          doc.setFontSize(12);
          doc.text(`Generated on ${new Date().toLocaleDateString()}`, 20, 30);
          doc.text('Set Hardware Management', 20, 40);
          doc.setLineWidth(0.5);
          doc.line(20, 45, 190, 45);

          const tableData = [[
            order.itemName || 'N/A',
            order.pickupFrom || 'N/A',
            order.orderNumber || 'N/A',
            order.deliveryMethod || 'N/A',
            order.deliveryMethod === 'pickup' ? (order.deliveryDate || 'N/A') : `${order.startDate || 'N/A'} to ${order.endDate || 'N/A'}`,
            order.recipient || 'N/A',
            order.received ? `Received${order.pickedUpBy ? ' by ' + order.pickedUpBy : ''}` : 'Not Received',
            order.receivedAt ? order.receivedAt.toLocaleString() : 'N/A',
            order.imageUrl || 'N/A'
          ]];

          doc.autoTable({
            startY: 50,
            head: [['Item Name', 'Pickup From', 'Order Number', 'Delivery', 'Dates', 'Recipient', 'Status', 'Received At', 'Image URL']],
            body: tableData,
            theme: 'grid',
            styles: { fontSize: 10, cellPadding: 3, overflow: 'linebreak' },
            columnStyles: {
              0: { cellWidth: 25 },
              1: { cellWidth: 20 },
              2: { cellWidth: 20 },
              3: { cellWidth: 15 },
              4: { cellWidth: 25 },
              5: { cellWidth: 20 },
              6: { cellWidth: 20 },
              7: { cellWidth: 20 },
              8: { cellWidth: 25 }
            }
          });

          doc.save(`Order_${order.orderNumber || order.id}.pdf`);
          console.log(`Generated order form for order: ${order.id}`);
        } catch (error) {
          console.error('Error generating order form:', error.message);
          setError(`Error generating order form: ${error.message}`);
        }
      };

      // Function to escape CSV values
      const escapeCsv = (str) => {
        if (!str) return '';
        return `"${str.replace(/"/g, '""')}"`;
      };

      // Generate CSV for export
      const generateCsv = (orders, title) => {
        try {
          const groupedOrders = orders.reduce((acc, order) => {
            const setName = order.set || 'Unknown Set';
            if (!acc[setName]) acc[setName] = [];
            acc[setName].push(order);
            return acc;
          }, {});

          let csvContent = 'Set,Item Name,Pickup From,Order Number,Delivery Method,Shipping Start Date,Shipping End Date,Delivery Date,Recipient,Received,Picked Up By,Received At,Image URL\n';
          Object.keys(groupedOrders).sort().forEach(setName => {
            groupedOrders[setName]
              .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
              .forEach(order => {
                const status = order.received ? `Received${order.pickedUpBy ? ' by ' + order.pickedUpBy : ''}` : 'Not Received';
                const receivedAt = order.receivedAt ? order.receivedAt.toLocaleString() : '';
                csvContent += `${escapeCsv(setName)},${escapeCsv(order.itemName)},${escapeCsv(order.pickupFrom)},${escapeCsv(order.orderNumber)},${escapeCsv(order.deliveryMethod)},${escapeCsv(order.startDate || '')},${escapeCsv(order.endDate || '')},${escapeCsv(order.deliveryDate || '')},${escapeCsv(order.recipient)},${escapeCsv(status)},${escapeCsv(order.pickedUpBy || '')},${escapeCsv(receivedAt)},${escapeCsv(order.imageUrl || '')}\n`;
              });
          });
          return csvContent;
        } catch (error) {
          console.error('Error generating CSV:', error.message);
          throw new Error(`Failed to generate CSV: ${error.message}`);
        }
      };

      // Export CSV for a given set of orders
      const exportToCsv = (orders, title) => {
        console.log(`Exporting CSV for ${title}`);
        try {
          const csvContent = generateCsv(orders, title);
          const blob = new Blob([csvContent], { type: 'text/csv' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${title.replace(/\s+/g, '_')}.csv`;
          a.click();
          URL.revokeObjectURL(url);
          console.log(`Generated CSV file for ${title}`);
        } catch (error) {
          console.error('Error generating CSV:', error.message);
          setError(`Error generating CSV: ${error.message}`);
        }
      };

      // Generate PDF with jsPDF
      const exportToPDF = (orders, title) => {
        console.log(`Exporting PDF for ${title}`);
        try {
          const doc = new jsPDF();
          doc.setFontSize(16);
          doc.text(title, 20, 20);
          doc.setFontSize(12);
          doc.text(`Generated on ${new Date().toLocaleDateString()}`, 20, 30);

          const groupedOrders = orders.reduce((acc, order) => {
            const setName = order.set || 'Unknown Set';
            if (!acc[setName]) acc[setName] = [];
            acc[setName].push(order);
            return acc;
          }, {});

          let y = 40;
          Object.keys(groupedOrders).sort().forEach(setName => {
            doc.setFontSize(14);
            doc.text(`Set: ${setName}`, 20, y);
            y += 10;

            const tableData = groupedOrders[setName]
              .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
              .map(order => {
                const status = order.received ? `Received${order.pickedUpBy ? ' by ' + order.pickedUpBy : ''}` : 'Not Received';
                const dates = order.deliveryMethod === 'pickup' ? (order.deliveryDate || '') : `${order.startDate || ''} to ${order.endDate || ''}`;
                const receivedAt = order.receivedAt ? order.receivedAt.toLocaleString() : '';
                return [
                  order.itemName || '',
                  order.pickupFrom || '',
                  order.orderNumber || '',
                  order.deliveryMethod || '',
                  dates,
                  order.recipient || '',
                  status,
                  receivedAt,
                  order.imageUrl || ''
                ];
              });

            doc.autoTable({
              startY: y,
              head: [['Item Name', 'Pickup From', 'Order Number', 'Delivery', 'Dates', 'Recipient', 'Status', 'Received At', 'Image URL']],
              body: tableData,
              theme: 'grid',
              styles: { fontSize: 8, cellPadding: 2, overflow: 'linebreak' },
              columnStyles: {
                0: { cellWidth: 25 },
                1: { cellWidth: 20 },
                2: { cellWidth: 20 },
                3: { cellWidth: 15 },
                4: { cellWidth: 25 },
                5: { cellWidth: 20 },
                6: { cellWidth: 20 },
                7: { cellWidth: 20 },
                8: { cellWidth: 25 }
              }
            });

            y = doc.lastAutoTable.finalY + 10;
            if (y > 270) {
              doc.addPage();
              y = 20;
            }
          });

          doc.save(`${title.replace(/\s+/g, '_')}.pdf`);
          console.log(`Generated PDF file for ${title}`);
        } catch (error) {
          console.error('Error generating PDF:', error.message);
          setError(`Error generating PDF: ${error.message}`);
        }
      };

      // Open modal with order details
      const openOrderModal = (order) => {
        setSelectedOrder(order);
        console.log('Opening modal for order:', order.id);
      };

      // Close modal
      const closeOrderModal = () => {
        setSelectedOrder(null);
        console.log('Closing modal');
      };

      // Define active and completed orders
      const activeOrders = orders.filter(order => !order.received);
      const completedOrders = orders.filter(order => order.received);

      // Filter orders by recipient
      const filteredActiveOrders = recipientFilter
        ? activeOrders.filter(order => order.recipient === recipientFilter)
        : activeOrders;
      const filteredCompletedOrders = recipientFilter
        ? completedOrders.filter(order => order.recipient === recipientFilter)
        : completedOrders;

      // Group filtered completed orders by set
      const groupedCompletedOrders = filteredCompletedOrders.reduce((acc, order) => {
        const setName = order.set || 'Unknown Set';
        if (!acc[setName]) acc[setName] = [];
        acc[setName].push(order);
        return acc;
      }, {});

      // Group archived orders by set
      const groupedArchivedOrders = archivedOrders.reduce((acc, order) => {
        const setName = order.set || 'Unknown Set';
        if (!acc[setName]) acc[setName] = [];
        acc[setName].push(order);
        return acc;
      }, {});

      // Fallback UI if Firebase is not initialized
      if (!firebaseInitialized) {
        return (
          <div className="container mx-auto p-4">
            <h1 className="text-3xl font-bold mb-6 text-center">Hardware Order Management</h1>
            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
              Error: Firebase not initialized. Please check your Firebase configuration and ensure the project is active.
            </div>
          </div>
        );
      }

      return (
        <ErrorBoundary>
          <div className="container mx-auto p-4">
            <h1 className="text-3xl font-bold mb-6 text-center">Hardware Order Management</h1>

            {/* Tabs */}
            <div className="flex border-b mb-6">
              <button
                className={`px-4 py-2 font-semibold ${activeTab === 'home' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-600'}`}
                onClick={() => setActiveTab('home')}
              >
                Home
              </button>
              <button
                className={`px-4 py-2 font-semibold ${activeTab === 'completed' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-600'}`}
                onClick={() => setActiveTab('completed')}
              >
                Completed Orders
              </button>
              <button
                className={`px-4 py-2 font-semibold ${activeTab === 'options' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-600'}`}
                onClick={() => setActiveTab('options')}
              >
                Options
              </button>
              <button
                className={`px-4 py-2 font-semibold ${activeTab === 'orders' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-600'}`}
                onClick={() => setActiveTab('orders')}
              >
                Orders
              </button>
              <button
                className={`px-4 py-2 font-semibold ${activeTab === 'archive' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-600'}`}
                onClick={() => setActiveTab('archive')}
              >
                Archive
              </button>
            </div>

            {/* Error Display */}
            {error && (
              <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
                {error}
              </div>
            )}

            {/* Received Modal */}
            {showReceivedModal && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div className="bg-white p-8 rounded-lg shadow-lg max-w-md w-full">
                  <h2 className="text-2xl font-semibold mb-4">Mark Order as Received</h2>
                  <div className="space-y-4">
                    <p>Select the person who picked up the order:</p>
                    <select
                      value={pickedUpBy}
                      onChange={(e) => setPickedUpBy(e.target.value)}
                      className="w-full p-2 border rounded"
                      required
                    >
                      <option value="" disabled>Select Pickup Person</option>
                      {recipients.map(recipient => (
                        <option key={recipient.id} value={recipient.name}>{recipient.name}</option>
                      ))}
                    </select>
                    <div className="flex space-x-2">
                      <button
                        onClick={confirmReceived}
                        className="w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                        disabled={!pickedUpBy}
                      >
                        Confirm
                      </button>
                      <button
                        onClick={closeReceivedModal}
                        className="w-full bg-gray-500 text-white p-2 rounded hover:bg-gray-600"
                      >
                        Cancel
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* Edit Order Modal */}
            {editOrder && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div className="bg-white p-8 rounded-lg shadow-lg max-w-lg w-full">
                  <h2 className="text-2xl font-semibold mb-4">Edit Order</h2>
                  <form onSubmit={handleEditSubmit} className="space-y-4">
                    <input
                      type="text"
                      name="itemName"
                      value={editOrder.itemName}
                      onChange={handleEditInputChange}
                      placeholder="Item Name"
                      className="w-full p-2 border rounded"
                      required
                    />
                    <input
                      type="text"
                      name="pickupFrom"
                      value={editOrder.pickupFrom}
                      onChange={handleEditInputChange}
                      placeholder="Pickup From"
                      className="w-full p-2 border rounded"
                      required
                    />
                    <input
                      type="text"
                      name="orderNumber"
                      value={editOrder.orderNumber}
                      onChange={handleEditInputChange}
                      placeholder="Order Number"
                      className="w-full p-2 border rounded"
                      required
                    />
                    <select
                      name="deliveryMethod"
                      value={editOrder.deliveryMethod}
                      onChange={handleEditInputChange}
                      className="w-full p-2 border rounded"
                    >
                      <option value="shipped">Shipped</option>
                      <option value="pickup">Pickup</option>
                    </select>
                    {editOrder.deliveryMethod === 'pickup' ? (
                      <input
                        type="date"
                        name="deliveryDate"
                        value={editOrder.deliveryDate}
                        onChange={handleEditInputChange}
                        placeholder="Delivery Date"
                        className="w-full p-2 border rounded"
                        required
                      />
                    ) : (
                      <div className="flex space-x-2">
                        <input
                          type="date"
                          name="startDate"
                          value={editOrder.startDate}
                          onChange={handleEditInputChange}
                          placeholder="Shipping Start Date"
                          className="w-full p-2 border rounded"
                          required
                        />
                        <input
                          type="date"
                          name="endDate"
                          value={editOrder.endDate}
                          onChange={handleEditInputChange}
                          placeholder="Shipping End Date"
                          className="w-full p-2 border rounded"
                          required
                        />
                      </div>
                    )}
                    <input
                      type="file"
                      onChange={handleImageChange}
                      accept="image/*"
                      className="w-full p-2 border rounded"
                    />
                    <select
                      name="set"
                      value={editOrder.set}
                      onChange={handleEditInputChange}
                      className="w-full p-2 border rounded"
                      required
                    >
                      <option value="">Select Set</option>
                      {sets.map(set => (
                        <option key={set.id} value={set.name}>{set.name}</option>
                      ))}
                    </select>
                    <select
                      name="recipient"
                      value={editOrder.recipient}
                      onChange={handleEditInputChange}
                      className="w-full p-2 border rounded"
                      required
                    >
                      <option value="">Select Recipient</option>
                      {recipients.map(recipient => (
                        <option key={recipient.id} value={recipient.name}>{recipient.name}</option>
                      ))}
                    </select>
                    <div className="flex space-x-2">
                      <button
                        type="submit"
                        className="w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                      >
                        Save Changes
                      </button>
                      <button
                        onClick={closeEditModal}
                        className="w-full bg-gray-500 text-white p-2 rounded hover:bg-gray-600"
                      >
                        Cancel
                      </button>
                    </div>
                  </form>
                </div>
              </div>
            )}

            {/* Order Modal */}
            {selectedOrder && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div className="bg-white p-8 rounded-lg shadow-lg max-w-lg w-full">
                  <h2 className="text-2xl font-semibold mb-4">Order Details</h2>
                  <div className="space-y-4 text-lg">
                    <p><strong>Item Name:</strong> {selectedOrder.itemName || 'N/A'}</p>
                    <p><strong>Pickup From:</strong> {selectedOrder.pickupFrom || 'N/A'}</p>
                    <p><strong>Order Number:</strong> {selectedOrder.orderNumber || 'N/A'}</p>
                    <p><strong>Delivery:</strong> {selectedOrder.deliveryMethod || 'N/A'}</p>
                    <p><strong>Dates:</strong> {selectedOrder.deliveryMethod === 'pickup' ? (selectedOrder.deliveryDate || 'N/A') : `${selectedOrder.startDate || 'N/A'} to ${selectedOrder.endDate || 'N/A'}`}</p>
                    <p><strong>Set:</strong> {selectedOrder.set || 'N/A'}</p>
                    <p><strong>Recipient:</strong> {selectedOrder.recipient || 'N/A'}</p>
                    <p><strong>Received:</strong> {selectedOrder.received ? 'Yes' : 'No'}</p>
                    {selectedOrder.received && selectedOrder.pickedUpBy && (
                      <p><strong>Picked Up By:</strong> {selectedOrder.pickedUpBy}</p>
                    )}
                    {selectedOrder.received && selectedOrder.receivedAt && (
                      <p><strong>Received At:</strong> {selectedOrder.receivedAt.toLocaleString()}</p>
                    )}
                    {selectedOrder.imageUrl && (
                      <div>
                        <p><strong>Image:</strong></p>
                        <img src={selectedOrder.imageUrl} alt="Order item" className="w-full max-h-96 object-contain rounded" />
                      </div>
                    )}
                  </div>
                  <button
                    onClick={closeOrderModal}
                    className="mt-6 w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                  >
                    Close
                  </button>
                </div>
              </div>
            )}

            {/* Home Tab (Active Orders) */}
            {activeTab === 'home' && (
              <div>
                <div className="flex justify-between items-center mb-4">
                  <select
                    value={recipientFilter}
                    onChange={(e) => setRecipientFilter(e.target.value)}
                    className="p-2 border rounded"
                  >
                    <option value="">All Recipients</option>
                    {recipients.map(recipient => (
                      <option key={recipient.id} value={recipient.name}>{recipient.name}</option>
                    ))}
                  </select>
                  <div className="flex space-x-2">
                    <button
                      onClick={() => exportToCsv(filteredActiveOrders, 'Active Orders')}
                      className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                      disabled={!firebaseInitialized}
                    >
                      Export Active Orders to CSV
                    </button>
                    <button
                      onClick={() => exportToPDF(filteredActiveOrders, 'Active Orders')}
                      className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                      disabled={!firebaseInitialized}
                    >
                      Export Active Orders to PDF
                    </button>
                  </div>
                </div>
                <h2 className="text-2xl font-semibold mb-4">Active Orders</h2>
                {filteredActiveOrders.length === 0 ? (
                  <p className="text-gray-600">No active orders found.</p>
                ) : (
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    {filteredActiveOrders.map(order => (
                      <div key={order.id} className="bg-white p-6 rounded-lg shadow-lg border-2 border-gray-300 relative">
                        {isOrderNew(order) && (
                          <span className="absolute top-2 right-2 bg-green-500 text-white text-xs px-2 py-1 rounded">New</span>
                        )}
                        <h3 className="text-xl font-semibold mb-2">{order.itemName || 'N/A'}</h3>
                        <p><strong>Pickup From:</strong> {order.pickupFrom || 'N/A'}</p>
                        <p><strong>Order Number:</strong> {order.orderNumber || 'N/A'}</p>
                        <p><strong>Delivery:</strong> {order.deliveryMethod || 'N/A'}</p>
                        <p><strong>Dates:</strong> {order.deliveryMethod === 'pickup' ? (order.deliveryDate || 'N/A') : `${order.startDate || 'N/A'} to ${order.endDate || 'N/A'}`}</p>
                        <p><strong>Set:</strong> {order.set || 'N/A'}</p>
                        <p><strong>Recipient:</strong> {order.recipient || 'N/A'}</p>
                        <p><strong>Received:</strong> {order.received ? 'Yes' : 'No'}</p>
                        {order.imageUrl && (
                          <img src={order.imageUrl} alt="Order item" className="w-full h-32 object-cover rounded mt-2" />
                        )}
                        <div className="mt-4 flex flex-wrap gap-2">
                          <button
                            onClick={() => openReceivedModal(order.id)}
                            className="flex-1 bg-green-500 text-white p-2 rounded hover:bg-green-600"
                          >
                            Received
                          </button>
                          <button
                            onClick={() => openOrderModal(order)}
                            className="flex-1 bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                          >
                            Expand
                          </button>
                          <button
                            onClick={() => openEditModal(order)}
                            className="flex-1 bg-yellow-500 text-white p-2 rounded hover:bg-yellow-600"
                          >
                            Edit
                          </button>
                          <button
                            onClick={() => deleteOrder(order.id)}
                            className="flex-1 bg-red-500 text-white p-2 rounded hover:bg-red-600"
                          >
                            Delete
                          </button>
                          <button
                            onClick={() => printOrderForm(order)}
                            className="flex-1 bg-purple-500 text-white p-2 rounded hover:bg-purple-600"
                          >
                            Print Order
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}

            {/* Orders Tab (New Order Form Only) */}
            {activeTab === 'orders' && (
              <div className="max-w-lg mx-auto bg-white p-6 rounded-lg shadow-md border-2 border-gray-300">
                <h2 className="text-2xl font-semibold mb-4">New Order</h2>
                <form onSubmit={handleSubmit} className="space-y-4">
                  <input
                    type="text"
                    name="itemName"
                    value={formData.itemName}
                    onChange={handleInputChange}
                    placeholder="Item Name"
                    className="w-full p-2 border rounded"
                    required
                  />
                  <input
                    type="text"
                    name="pickupFrom"
                    value={formData.pickupFrom}
                    onChange={handleInputChange}
                    placeholder="Pickup From"
                    className="w-full p-2 border rounded"
                    required
                  />
                  <input
                    type="text"
                    name="orderNumber"
                    value={formData.orderNumber}
                    onChange={handleInputChange}
                    placeholder="Order Number"
                    className="w-full p-2 border rounded"
                    required
                  />
                  <select
                    name="deliveryMethod"
                    value={formData.deliveryMethod}
                    onChange={handleInputChange}
                    className="w-full p-2 border rounded"
                  >
                    <option value="shipped">Shipped</option>
                    <option value="pickup">Pickup</option>
                  </select>
                  {formData.deliveryMethod === 'pickup' ? (
                    <input
                      type="date"
                      name="deliveryDate"
                      value={formData.deliveryDate}
                      onChange={handleInputChange}
                      placeholder="Delivery Date"
                      className="w-full p-2 border rounded"
                      required
                    />
                  ) : (
                    <div className="flex space-x-2">
                      <input
                        type="date"
                        name="startDate"
                        value={formData.startDate}
                        onChange={handleInputChange}
                        placeholder="Shipping Start Date"
                        className="w-full p-2 border rounded"
                        required
                      />
                      <input
                        type="date"
                        name="endDate"
                        value={formData.endDate}
                        onChange={handleInputChange}
                        placeholder="Shipping End Date"
                        className="w-full p-2 border rounded"
                        required
                      />
                    </div>
                  )}
                  <input
                    type="file"
                    onChange={handleImageChange}
                    accept="image/*"
                    className="w-full p-2 border rounded"
                  />
                  <select
                    name="set"
                    value={formData.set}
                    onChange={handleInputChange}
                    className="w-full p-2 border rounded"
                    required
                  >
                    <option value="">Select Set</option>
                    {sets.map(set => (
                      <option key={set.id} value={set.name}>{set.name}</option>
                    ))}
                  </select>
                  <select
                    name="recipient"
                    value={formData.recipient}
                    onChange={handleInputChange}
                    className="w-full p-2 border rounded"
                    required
                  >
                    <option value="">Select Recipient</option>
                    {recipients.map(recipient => (
                      <option key={recipient.id} value={recipient.name}>{recipient.name}</option>
                    ))}
                  </select>
                  <button
                    type="submit"
                    disabled={uploading || !firebaseInitialized}
                    className="w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600 disabled:bg-blue-300"
                  >
                    {uploading ? 'Submitting...' : 'Submit Order'}
                  </button>
                </form>
              </div>
            )}

            {/* Options Tab */}
            {activeTab === 'options' && (
              <ErrorBoundary>
                <div className="max-w-lg mx-auto bg-white p-6 rounded-lg shadow-md border-2 border-gray-300">
                  <h2 className="text-2xl font-semibold mb-4">Options</h2>
                  <div className="space-y-6">
                    {/* Manage Sets */}
                    <div>
                      <h3 className="text-lg font-semibold mb-2">Manage Sets</h3>
                      <form onSubmit={addSet} className="flex space-x-2 mb-4">
                        <input
                          type="text"
                          value={newSet}
                          onChange={(e) => setNewSet(e.target.value)}
                          placeholder="Add New Set"
                          className="w-full p-2 border rounded"
                        />
                        <button
                          type="submit"
                          disabled={!firebaseInitialized}
                          className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600 disabled:bg-blue-300"
                        >
                          Add
                        </button>
                      </form>
                      <ul className="space-y-2">
                        {sets.length === 0 ? (
                          <li className="text-gray-600">No sets available.</li>
                        ) : (
                          sets.map(set => (
                            <li key={set.id} className="flex justify-between items-center">
                              <span>{set.name || 'Unnamed Set'}</span>
                              <button
                                onClick={() => deleteSet(set.id, set.name)}
                                className="text-red-500 hover:text-red-700"
                                disabled={!firebaseInitialized}
                              >
                                Delete
                              </button>
                            </li>
                          ))
                        )}
                      </ul>
                    </div>
                    {/* Manage Recipients */}
                    <div>
                      <h3 className="text-lg font-semibold mb-2">Manage Recipients</h3>
                      <form onSubmit={addRecipient} className="flex space-x-2 mb-4">
                        <input
                          type="text"
                          value={newRecipient}
                          onChange={(e) => setNewRecipient(e.target.value)}
                          placeholder="Add New Recipient"
                          className="w-full p-2 border rounded"
                        />
                        <button
                          type="submit"
                          disabled={!firebaseInitialized}
                          className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600 disabled:bg-blue-300"
                        >
                          Add
                        </button>
                      </form>
                      <ul className="space-y-2">
                        {recipients.length === 0 ? (
                          <li className="text-gray-600">No recipients available.</li>
                        ) : (
                          recipients.map(recipient => (
                            <li key={recipient.id} className="flex justify-between items-center">
                              <span>{recipient.name || 'Unnamed Recipient'}</span>
                              <button
                                onClick={() => deleteRecipient(recipient.id)}
                                className="text-red-500 hover:text-red-700"
                                disabled={!firebaseInitialized}
                              >
                                Delete
                              </button>
                            </li>
                          ))
                        )}
                      </ul>
                    </div>
                  </div>
                </div>
              </ErrorBoundary>
            )}

            {/* Completed Orders Tab */}
            {activeTab === 'completed' && (
              <div className="max-w-4xl mx-auto">
                <div className="flex justify-between items-center mb-4">
                  <select
                    value={recipientFilter}
                    onChange={(e) => setRecipientFilter(e.target.value)}
                    className="p-2 border rounded"
                  >
                    <option value="">All Recipients</option>
                    {recipients.map(recipient => (
                      <option key={recipient.id} value={recipient.name}>{recipient.name}</option>
                    ))}
                  </select>
                  <div className="flex space-x-2">
                    <button
                      onClick={() => exportToCsv(filteredCompletedOrders, 'Completed Orders')}
                      className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                      disabled={!firebaseInitialized}
                    >
                      Export Completed Orders to CSV
                    </button>
                    <button
                      onClick={() => exportToPDF(filteredCompletedOrders, 'Completed Orders')}
                      className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                      disabled={!firebaseInitialized}
                    >
                      Export Completed Orders to PDF
                    </button>
                  </div>
                </div>
                <h2 className="text-2xl font-semibold mb-4">Completed Orders</h2>
                {Object.keys(groupedCompletedOrders).length === 0 ? (
                  <p className="text-gray-600">No completed orders found.</p>
                ) : (
                  Object.keys(groupedCompletedOrders).sort().map(setName => (
                    <div key={setName} className="mb-8">
                      <h3 className="text-xl font-semibold mb-4">{setName}</h3>
                      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        {groupedCompletedOrders[setName]
                          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
                          .map(order => (
                            <div key={order.id} className="bg-white p-6 rounded-lg shadow-lg border-2 border-gray-300 relative">
                              {isOrderNew(order) && (
                                <span className="absolute top-2 right-2 bg-green-500 text-white text-xs px-2 py-1 rounded">New</span>
                              )}
                              <h4 className="text-lg font-semibold mb-2">{order.itemName || 'N/A'}</h4>
                              <p><strong>Pickup From:</strong> {order.pickupFrom || 'N/A'}</p>
                              <p><strong>Order Number:</strong> {order.orderNumber || 'N/A'}</p>
                              <p><strong>Delivery:</strong> {order.deliveryMethod || 'N/A'}</p>
                              <p><strong>Dates:</strong> {order.deliveryMethod === 'pickup' ? (order.deliveryDate || 'N/A') : `${order.startDate || 'N/A'} to ${order.endDate || 'N/A'}`}</p>
                              <p><strong>Recipient:</strong> {order.recipient || 'N/A'}</p>
                              <p><strong>Received:</strong> Yes</p>
                              {order.pickedUpBy && (
                                <p><strong>Picked Up By:</strong> {order.pickedUpBy}</p>
                              )}
                              {order.receivedAt && (
                                <p><strong>Received At:</strong> {order.receivedAt.toLocaleString()}</p>
                              )}
                              {order.imageUrl && (
                                <img src={order.imageUrl} alt="Order item" className="w-full h-32 object-cover rounded mt-2" />
                              )}
                              <div className="mt-4 flex flex-wrap gap-2">
                                <button
                                  onClick={() => toggleReceived(order.id, order.received)}
                                  className="flex-1 bg-gray-500 text-white p-2 rounded hover:bg-gray-600"
                                >
                                  Undo Received
                                </button>
                                <button
                                  onClick={() => openOrderModal(order)}
                                  className="flex-1 bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                                >
                                  Expand
                                </button>
                                <button
                                  onClick={() => openEditModal(order)}
                                  className="flex-1 bg-yellow-500 text-white p-2 rounded hover:bg-yellow-600"
                                >
                                  Edit
                                </button>
                                <button
                                  onClick={() => deleteOrder(order.id)}
                                  className="flex-1 bg-red-500 text-white p-2 rounded hover:bg-red-600"
                                >
                                  Delete
                                </button>
                                <button
                                  onClick={() => printOrderForm(order)}
                                  className="flex-1 bg-purple-500 text-white p-2 rounded hover:bg-purple-600"
                                >
                                  Print Order
                                </button>
                              </div>
                            </div>
                          ))}
                      </div>
                    </div>
                  ))
                )}
              </div>
            )}

            {/* Archive Tab */}
            {activeTab === 'archive' && (
              <div className="max-w-4xl mx-auto">
                <div className="flex justify-end space-x-2 mb-4">
                  <button
                    onClick={() => exportToCsv(archivedOrders, 'Archived Orders')}
                    className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                    disabled={!firebaseInitialized}
                  >
                    Export Archived Orders to CSV
                  </button>
                  <button
                    onClick={() => exportToPDF(archivedOrders, 'Archived Orders')}
                    className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                    disabled={!firebaseInitialized}
                  >
                    Export Archived Orders to PDF
                  </button>
                </div>
                <h2 className="text-2xl font-semibold mb-4">Archived Orders</h2>
                {Object.keys(groupedArchivedOrders).length === 0 ? (
                  <p className="text-gray-600">No archived orders found.</p>
                ) : (
                  Object.keys(groupedArchivedOrders).sort().map(setName => (
                    <div key={setName} className="mb-8">
                      <div className="flex justify-between items-center mb-4">
                        <h3 className="text-xl font-semibold">{setName}</h3>
                        <button
                          onClick={() => restoreSet(setName)}
                          className="bg-green-500 text-white p-2 rounded hover:bg-green-600"
                          disabled={!firebaseInitialized}
                        >
                          Restore Set
                        </button>
                      </div>
                      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        {groupedArchivedOrders[setName].map(order => (
                          <div key={order.id} className="bg-white p-6 rounded-lg shadow-lg border-2 border-gray-300 relative">
                            {isOrderNew(order) && (
                              <span className="absolute top-2 right-2 bg-green-500 text-white text-xs px-2 py-1 rounded">New</span>
                            )}
                            <h4 className="text-lg font-semibold mb-2">{order.itemName || 'N/A'}</h4>
                            <p><strong>Pickup From:</strong> {order.pickupFrom || 'N/A'}</p>
                            <p><strong>Order Number:</strong> {order.orderNumber || 'N/A'}</p>
                            <p><strong>Delivery:</strong> {order.deliveryMethod || 'N/A'}</p>
                            <p><strong>Dates:</strong> {order.deliveryMethod === 'pickup' ? (order.deliveryDate || 'N/A') : `${order.startDate || 'N/A'} to ${order.endDate || 'N/A'}`}</p>
                            <p><strong>Recipient:</strong> {order.recipient || 'N/A'}</p>
                            <p><strong>Received:</strong> {order.received ? 'Yes' : 'No'}</p>
                            {order.received && order.pickedUpBy && (
                              <p><strong>Picked Up By:</strong> {order.pickedUpBy}</p>
                            )}
                            {order.received && order.receivedAt && (
                              <p><strong>Received At:</strong> {order.receivedAt.toLocaleString()}</p>
                            )}
                            {order.imageUrl && (
                              <img src={order.imageUrl} alt="Order item" className="w-full h-32 object-cover rounded mt-2" />
                            )}
                            <div className="mt-4">
                              <button
                                onClick={() => openOrderModal(order)}
                                className="w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
                              >
                                Expand
                              </button>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  ))
                )}
              </div>
            )}
          </div>
        </ErrorBoundary>
      );
    }

    // Render the app with global error boundary
    try {
      ReactDOM.render(<ErrorBoundary><App /></ErrorBoundary>, document.getElementById('root'));
    } catch (error) {
      console.error('React render error:', error.message);
      document.getElementById('root').innerHTML = '<div className="text-red-500 text-center">Error loading application: ' + error.message + '</div>';
    }
  </script>
</body>
</html>
